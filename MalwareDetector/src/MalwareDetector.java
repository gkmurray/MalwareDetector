/**
 * @(#)VirusScanner.java
 *
 * VirusScanner application
 *
 * @author	Greg Muray (111919)
 * @version 1.00 2012/3/28
 */
 //	This program is a primitive virus detection program with the ability to locate
 //	potentially hazardous files and flag them to the users attention. Its execution
 //	is as follows:
 //
 //		Recursively traverse the file structure starting at a specified folder, and
 //		compile an ArrayList with FileAttribute objects. These objects contain import
 //		descriptions of a files current state, such as size, permissions, date last
 //		modified and a unique hash of their contents.
 //
 //		The now populate array is then scanned for any trace of the binary virus
 //		signature provided, relaying the status of each scan to the user.
 //
 //		The program then sits in memory, await a request by the user to scan again.
 //		New scans will populate a new ArrayList, and match their contents to the
 //		original ArrayList, flagging any files that show signs of modification.
 //		If any new files are detected as not having an entry in the original ArrayList,
 //		they are added and then automatically flagged for futher scan.
 //
 //		The new list of flagged files are further scanned for the provided binary
 //		virus signature, and have their status reported to the user.
 //
 //		Finally, the user is given the option to terminate the program, or to scan
 //		again.
 //
 //	As demonstrated above, the program works best when it is left to run, as at this
 //	time, it provides no methods for writing databases of file states to an output file.
 //	Future iterations would provide saving this information, as well as support for
 //	multiple virus signatures.
 //	The methods indexOf(), computeFailure(), calculateChecksum(), byteArrayToHexString()
 //	and hexStringToByteArray() were provided by StackOverflow.com, though were modified
 //	slighty to match the needs of the program.

import java.io.*;
import java.util.*;
import java.text.*;
import java.security.*;

public class MalwareDetector {

//	Program flow is directed by main, providing minimal user IO and calling the core methods.
    public static void main(String[] args) throws Exception {

    	MalwareDetector scanner = new MalwareDetector();
    	Scanner scan = new Scanner(System.in);

    	ArrayList<FileAttribute> fileAttributeList = new ArrayList<FileAttribute>();
    	ArrayList<FileAttribute> flaggedFileList = new ArrayList<FileAttribute>();

    	byte[] virusSignature = scanner.hexStringToByteArray("81FB943140000F833AFFFFFFBE000040008D7DE0");

    	String choice = null;
    	String exit = null;

    	String path = "C:\\Users\\Administrator\\Documents\\School";
    	File folder = new File(path);
    	File outputFile;

		System.out.println("Get List of Files");
    	System.out.println("----------------------------------------");
    	scanner.getFileAttributeList(folder, fileAttributeList, scanner);

    	System.out.println("");

		System.out.println("Scan List for Virus");
    	System.out.println("----------------------------------------");
    	scanner.checkForVirusSignatures(fileAttributeList, virusSignature, scanner);

    	System.out.println("");

		do{
    		System.out.println("Scan?");
    		choice = scan.next();

    		if(choice.equals("Y")) {

				System.out.println("Match New List Against Original For Changes");
    			System.out.println("----------------------------------------");
				flaggedFileList = scanner.checkForFileChanges(folder, fileAttributeList, scanner);

				System.out.println("");

				System.out.println("Scan List for Virus");
    			System.out.println("----------------------------------------");
				scanner.checkForVirusSignatures(flaggedFileList, virusSignature, scanner);
    		}

    		System.out.println("Exit?");
    		exit = scan.next();

    	} while(!(exit.equals("Y")));
	}

//	This method fills the provide ArrayList with FileAttribtes created from the specified folder, traversing any subtrees
//	recursivly. It can be specified to omit any file types from the second decision structure.
	private void getFileAttributeList(File folder, ArrayList<FileAttribute> fileAtrributeList, MalwareDetector scanner) throws Exception {

		File[] fileList = folder.listFiles();
		byte[] currentChecksum;
		String fileName;
		int index;

		for(int i = 0; i < fileList.length; i++) {
			if(fileList[i].isDirectory()) {
				getFileAttributeList(fileList[i], fileAtrributeList, scanner);
			}
			else {
            	fileName = fileList[i].getName();

                if (!(fileName.endsWith(".chk") || fileName.endsWith(".CHK"))) {

					currentChecksum = scanner.calculateChecksum((fileList[i]).getAbsolutePath());

					fileAtrributeList.add(new FileAttribute(fileList[i], currentChecksum));

					index = fileAtrributeList.size() - 1;
					System.out.println(fileAtrributeList.get(index) + " added at index " + index);
				}
            }
		}
	}

//	This method takes the passed ArrayList and checks it against a newly created list for any descripencies. After matching
// 	entries' Absolute Path to confirm equality, it compares all the relavent properties specified in FileAttribute to
//	check for changes. If any newly created FileAttributes property does not match the entry previously stored, it is
//	flagged and put into a flaggedFileLast to be returned for futher analyis. Files that are found to not have a previous
//	entries (e.g. files that were created since last scan) are automatically flagged and added to the flaggedFileLast.
	private ArrayList<FileAttribute> checkForFileChanges(File folder, ArrayList<FileAttribute> fileAttributeList, MalwareDetector scanner) throws Exception{

		ArrayList<FileAttribute> flaggedFileList = new ArrayList<FileAttribute>();
		ArrayList<FileAttribute> newFileAttributeList = new ArrayList<FileAttribute>();
		FileAttribute foundFileAttribute;
		boolean flagged = false;

		scanner.getFileAttributeList(folder, newFileAttributeList, scanner);

		for(int i = 0; i < newFileAttributeList.size(); i++) {

			//Search for a match
			foundFileAttribute = scanner.findMatch(newFileAttributeList.get(i), fileAttributeList);

			//If the file was located in the original database
			if(foundFileAttribute != null) {
				//Compare file attributes
				if(!(Arrays.equals(newFileAttributeList.get(i).getChecksum(), foundFileAttribute.getChecksum()))) {
					System.out.println((scanner.byteArrayToHexString(newFileAttributeList.get(i).getChecksum())) + " Does not equal " + (scanner.byteArrayToHexString(foundFileAttribute.getChecksum())));
					flagged = true;
				}
				if(newFileAttributeList.get(i).getFileSize() != foundFileAttribute.getFileSize()) {
					System.out.println(newFileAttributeList.get(i).getFileSize() + " Does not equal " + foundFileAttribute.getFileSize());
					flagged = true;
				}
				if(newFileAttributeList.get(i).getDateLastModified() != foundFileAttribute.getDateLastModified()) {
					System.out.println(newFileAttributeList.get(i).getDateLastModified() + " Does not equal " + foundFileAttribute.getDateLastModified());
					flagged = true;
				}
				if(newFileAttributeList.get(i).getReadPermission() != foundFileAttribute.getReadPermission()) {
					System.out.println(newFileAttributeList.get(i).getReadPermission() + " Does not equal " + foundFileAttribute.getReadPermission());
					flagged = true;
				}
				if(newFileAttributeList.get(i).getWritePermission() != foundFileAttribute.getWritePermission()) {
					System.out.println(newFileAttributeList.get(i).getWritePermission() + " Does not equal " + foundFileAttribute.getWritePermission());
					flagged = true;
				}
				if(newFileAttributeList.get(i).getExecutePermission() != foundFileAttribute.getExecutePermission()) {
					System.out.println(newFileAttributeList.get(i).getExecutePermission() + " Does not equal " + foundFileAttribute.getExecutePermission());
					flagged = true;
				}
				if(flagged) {
					System.out.println(newFileAttributeList.get(i));
					System.out.println("This file has been modified since last compilation");
					System.out.println("***");
				}
				else {
					System.out.println(newFileAttributeList.get(i));
					System.out.println("No changes detected");
					System.out.println("***");
				}
			}

			//If the file was created since last compilation, add it to the database, and flag it for virus scan
			else {
				fileAttributeList.add(newFileAttributeList.get(i));
				flagged = true;

				System.out.println(newFileAttributeList.get(i));
				System.out.println("New file was added to the database and flagged for full scan");
				System.out.println("***");
			}

			if(flagged) {
					flaggedFileList.add(newFileAttributeList.get(i));
				}

			//Reset flag for next file
			flagged = false;
		}

		return flaggedFileList;

	}

//	This method searches the provided ArrayList for the target entry, returning its corresponding entry
// 	if found, and null if it is not.
	private FileAttribute findMatch(FileAttribute target, ArrayList<FileAttribute> fileAttributeList) {
		boolean found = false;
		int index = 0;

		while(!found && index < fileAttributeList.size()) {
			if(target.compareTo(fileAttributeList.get(index)) == 0) {
				found = true;
			}
			else {
				index++;
			}
		}
		if (found) {
			return fileAttributeList.get(index);
		}
		else {
			return null;
		}
	}

//	This method gets a dump of all files in the specified list and and compares them against the provided
//	virus signatures. It then prints out all files and indicates if any had a match to the provided signature.
	private void checkForVirusSignatures(ArrayList<FileAttribute> flaggedFileList, byte[] virusSignature, MalwareDetector scanner) throws Exception{
		int index;
		byte[] currentFileContent;
		String readableCurrentFileContent;

		for(int i = 0; i < flaggedFileList.size(); i++) {
			currentFileContent = scanner.getByteArrayFromFile(flaggedFileList.get(i).getFile());

			//Test dump
			//readableCurrentFileContent = scanner.byteArrayToHexString(currentFileContent);
			System.out.println("Scanning: " + flaggedFileList.get(i).getFile().getAbsolutePath());
			//System.out.println("Hex dump of file contents: " + readableCurrentFileContent);

			index = scanner.indexOf(currentFileContent, virusSignature);

			if(index != -1) {
				System.out.println("Virus detected at byte array index " + index);
				readableCurrentFileContent = scanner.byteArrayToHexString(currentFileContent);
				System.out.println("Hex dump of file contents: " + readableCurrentFileContent);
			}
			else {
				System.out.println("No suspicous code detected");
			}

			System.out.println("***");
		}

	}
//	Finds the first occurrence of the pattern in the text
//	This method as well as its correspinding helper method computeFailure() was provided
//	by StackOverflow.com
	private int indexOf(byte[] data, byte[] pattern) {
      	int[] failure = computeFailure(pattern);

        int j = 0;
        if (data.length == 0) return -1;

        for (int i = 0; i < data.length; i++) {
            while (j > 0 && pattern[j] != data[i]) {
                j = failure[j - 1];
            }
            if (pattern[j] == data[i]) {
            	j++;
            }
            if (j == pattern.length) {
                return i - pattern.length + 1;
            }
        }
        return -1;
    }

//	Computes the failure function using a boot-strapping process,
//	where the pattern is matched against itself.
    private int[] computeFailure(byte[] pattern) {
        int[] failure = new int[pattern.length];

        int j = 0;
        for (int i = 1; i < pattern.length; i++) {
            while (j > 0 && pattern[j] != pattern[i]) {
                j = failure[j - 1];
            }
            if (pattern[j] == pattern[i]) {
                j++;
            }
            failure[i] = j;
        }

        return failure;
    }


//	This method reads a file into a byte array to be analysed by checkForVirusSignatures
	private byte[] getByteArrayFromFile(File thisFile) throws Exception{
		FileInputStream byteReader;
		byte[] fileContent = null;

		try {
			byteReader = new FileInputStream(thisFile);

			fileContent = new byte[(int)(thisFile.length())];

			byteReader.read(fileContent);
		}
     	catch(Exception e) {
        	e.printStackTrace();
     	}
		return fileContent;
	}

//	This method calculates a SHA1 (Secure Hashing Algorithm) for the provided file, and returns
//	it as a byte array.	This method was provided by StackOverflow.com
    private byte[] calculateChecksum(String filename) throws Exception{
     	InputStream fis =  new FileInputStream(filename);

    	byte[] buffer = new byte[1024];
    	MessageDigest complete = MessageDigest.getInstance("SHA1");
    	int numRead;
    	do {
     	 	numRead = fis.read(buffer);
       		if (numRead > 0) {
         		complete.update(buffer, 0, numRead);
       		}
     	} while (numRead != -1);{
     		//Keep Reading
     	}
     	fis.close();
     	return complete.digest();
  }

//	Formatting method to convert a byte array into a human-readable
// 	string it's corresponding hex form. This method was provided by StackOverflow.com
  	private String byteArrayToHexString(byte[] hash) {

  		Formatter formatter = new Formatter();
 			for (byte b : hash) {
     			formatter.format("%02x", b);
        	}
   		return formatter.toString();
  }

//	This method undoes byteArrayToHexString, returning the string to its byte array form.
//	This method was provided by StackOverflow.com
  	private byte[] hexStringToByteArray(String s) {
    	int len = s.length();
    	byte[] data = new byte[len / 2];
    	for (int i = 0; i < len; i += 2) {
        	data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) << 4) + Character.digit(s.charAt(i+1), 16));
    	}
    	return data;
	}


}

